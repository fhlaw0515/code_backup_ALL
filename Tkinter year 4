import tkinter as tk
root=tk.Tk()


Label1 = Label(root, text="Making a table of your university grading scale: \n\n Please tick the boxes if your assessment framework has these grades")
Label1.grid(row=0, sticky=W)
Label1
# each checkbox needs to have a variable, if it is ticked, it should be 1 I think, otherwise it will be zero
var1 = IntVar() 
varA = Checkbutton(root, text="A", variable=var1)
varA.grid(row=1, column = 1, sticky=W) # create a checkbox for the grade A
varA

var2 = IntVar()
varB = Checkbutton(root, text="B", variable=var2)
varB.grid(row=1, column = 2, sticky=W) # create a checkbox for grade B
varB

var3 = IntVar()
varC = Checkbutton(root, text="C", variable=var3)
varC.grid(row=1, column = 3, sticky=W) # create a checkbox 
varC

var4 = IntVar()
varD = Checkbutton(root, text="D", variable=var4)
varD.grid(row=2, column = 1, sticky=W) # create a checkbox 
varD

var5 = IntVar()
varE = Checkbutton(root, text="E", variable=var5)
varE.grid(row=2, column = 2,  sticky=W) # create a checkbox 
varE

var6 = IntVar()
varF = Checkbutton(root, text="F", variable=var6)
varF.grid(row=2, column = 3, sticky=W) # create a checkbox 
varF 

var7 = IntVar()
varG = Checkbutton(root, text="G", variable=var7)
varG.grid(row=3, column = 1,sticky=W) # create a checkbox 
varG

var8 = IntVar()
varH = Checkbutton(root, text="H", variable=var8)
varH.grid(row=3, column = 2, sticky=W) # create a checkbox 
varH

var9 = IntVar()
varI = Checkbutton(root, text="I", variable=var9)
varI.grid(row=3, column = 3, sticky=W) # create a checkbox 
varI

# create a list storing all variable states (either 0 or 1) of all checkbox button 
my_list = [var1,var2,var3,var4,var5,var6,var7,var8,var9]

# store all button object as a list
button_list = [varA,varB,varC,varD,varE,varF,varG,varH,varI]

# create the grade options list (a list of string of all available grades)
# e.g ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
grade_options = []
for element in button_list:
    grade_options.append(element['text'])

def checkbox_destroy(empty_list):
    for element in button_list:
        element.destroy()
    empty_list = empty_list
    grade_band(empty_list)

def grade_band(empty_list):
    length = len(empty_list)
    #greetingLabel = tk.Label(root,text='Please tell me the number of bands to each grades',font=('Arial',15))
    print(f"I need {length} dropdown menu.")
    Label1.configure(text='')
    list_selected = []
    index = 0
    for i in range(len(empty_list)):
        selected_value = tk.StringVar()
        selected_value.set("1")  # default value
        list_selected.append(selected_value)
        dropdown = tk.OptionMenu(root, selected_value, "1", "2", "3", "4", "5")
        dropdown.grid(row = index, column = 2)
        # Create a label for the grade before the dropdown menu
        label = tk.Label(root, text=empty_list[index])
        label.grid(row=index, column=1)
        index = index + 1
    label = tk.Label(root, text='   Please select the number of bands to each grade')
    label.grid(row = 1, column=3)
    submit_button.grid(column = 4,row = 3)
    quit_button.grid(column = 4, row = 4)


def calculate_state():
    dictionary = {}
    for alphabet, state in zip(grade_options, my_list): # my_list means the list of variable states!!!!
        dictionary[alphabet] = state.get() # create a dictionary with grade alphabet as key, variable state as value
    empty_list = [] # create a list called empty_list that will later store only the selected grade 
    for element in dictionary.items(): # loop through each key-value pair (each tuple)
        for value in element: # for each element in the tuple
            if value == 1: # if anything (the value) equals to 1 (the key will never be 1 yet we still checked it)
                empty_list.append(element[0]) # append the key (the alphabet grade)
    for element in empty_list:
        print(f"You have selected grade {element}")
    checkbox_destroy(empty_list)
    return empty_list


# clicking the submit button will call the calculate_state function
submit_button = Button(root, text='Submit', command=calculate_state)
submit_button.grid(row=4, column = 1, sticky=W, pady=4)
submit_button

quit_button = Button(root, text='Quit', command=root.quit)
quit_button.grid(row=4, column = 3, sticky=W, pady=4) # create a quit button, on call then the quit function will be applied to master the tk()
quit_button

mainloop()



###########################################################################################################################################################
############################################################# sort data of the csv course file ############################################################
###########################################################################################################################################################

import csv

# Specify the input and output file names
input_file = '/Path/course_credits.csv/'
output_file = 'Path/updated_courses.csv/'

updated_rows = []

with open(input_file, 'r', newline='') as csvfile:
    reader = csv.DictReader(csvfile)

    for row in reader:
        course = row['Course']

        # Assign Year and Type based on course name
        if course.endswith('3A'):
            row['Year'], row['Type'] = 3, 'A'
        elif course.endswith('3B'):
            row['Year'], row['Type'] = 3, 'B'
        elif course.endswith('CORE'):
            row['Year'], row['Type'] = 4, 'core'
        elif course.endswith('OPTION'):
            row['Year'], row['Type'] = 4, 'option'
        elif course.endswith('PROJECT'):
            row['Year'], row['Type'] = 4, 'project'
        else:
            continue  # I don't assign NA, instead I dumped those courses from the csv instead, not writing it

        updated_rows.append(row)

# Write to CSV 
if updated_rows: # if this is not an empty list
    with open(output_file, 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=updated_rows[0].keys())  # Auto-detect keys
        writer.writeheader()
        writer.writerows(updated_rows)

    print(f"Updated CSV saved as {output_file}")
else:
    print("No valid courses found.")

############################################################################################################################################################
################################### go to university website biology subject obtain course list for level 4 ################################################
############################################################################################################################################################

# could have output only 1 csv instead of 2 csv (one for course_list, one for course_assessment details without course name
# but leave it for now

from selenium import webdriver
from selenium.webdriver.common.by import By
import time
import pandas as pd

# Start WebDriver
driver = webdriver.Chrome()

# Open the webpage
url = "https://www.gla.ac.uk/coursecatalogue/courselist/?code=BIOL&name=Biology+and+Biomedical+Sciences"
driver.get(url)
time.sleep(3)  # Allow time for elements to load

# Accept cookies if needed
try:
    accept_button = driver.find_element(By.XPATH, "//button[contains(text(),'accept all')]")
    accept_button.click()
    time.sleep(0.5)
    print("Cookies accepted successfully.")
except:
    print("No 'accept all' button found or already accepted.")

# Click the Level 4 section link
try:
    level_4_link = driver.find_element(By.LINK_TEXT, "Level 4 (SCQF level 10)")
    driver.execute_script("arguments[0].scrollIntoView();", level_4_link)  # Scroll into view
    time.sleep(0.5)
    level_4_link.click()
    time.sleep(1)  # Allow content to load
except Exception as e:
    print(f"Could not click Level 4: {e}")

# Extract only Level 4 courses
try:
    level_4_section = driver.find_element(By.XPATH, "//h2[contains(text(), 'Level 4')]")
    # driver.find_element(By.XPATH, "//h2[contains(text(), 'Level 4')]")
    # ➜ This looks for an <h2> header containing the text "Level 4".
    # ➜ XPath syntax contains(text(), 'Level 4') helps find elements when the text isn't an exact match.
 
    course_list = level_4_section.find_element(By.XPATH, "./following-sibling::ul")
    # following-sibling::ul
    # ➜ This finds the next <ul> list that appears after the "Level 4" heading.
    # ➜ This ensures that we only get courses from Level 4 (ignoring other lists).
    
    courses = course_list.find_elements(By.TAG_NAME, "a")
    # Find all clickable course names (inside <a> tags)

    course_list = [] # make an empty list to store the output of course name and course code
    for course in courses:
        course_name = course.text.strip()
        course_url = course.get_attribute("href")
        #print(f"Course: {course_name}, URL: {course_url}")
        course_list.append({"Course": course_name, "url" : course_url})
    df = pd.DataFrame(course_list) # convert the list of dictionary into a dataframe


    credit_list = [] # create a list to store the credit
    assessment_string = []
    for url in df["url"].unique(): # try click on each url first
        driver.get(url)

        try:
            credits_element = driver.find_element(By.XPATH, "//li[strong[contains(text(),'Credits')]]")
            credit = credits_element.text.replace("Credits: ", "").strip()
            credit_list.append({"Credit": credit})

            assessment_element = driver.find_element(By.XPATH, "//h3[contains(text(),'Assessment')]")
            assessment = assessment_element.text.strip()

            # Locate the "Assessment" section first
            assessment_section = driver.find_element(By.XPATH, "//h3[contains(text(),'Assessment')]")

            # Find the FIRST div following the Assessment header
            first_div = assessment_section.find_element(By.XPATH, "./following-sibling::div[1]")

            # Extract all span elements inside this div
            spans = first_div.find_elements(By.TAG_NAME, "span")

            # Store assessment text
            assessment_text = []
            for span in spans:
                text = span.text.strip()
                assessment_text.append(text)

            # Join all collected spans into a readable sentence, thought of storing the spans for processing but maybe natural language processing should be used instead, faster, but haven't learnt
            final_assessment = " ".join(assessment_text)
            assessment_string.append({"Assessment": final_assessment})

        except Exception as e:
            print(f"Error extracting credits or assessment: {e}")

    assess = pd.DataFrame(assessment_string) # convert the list of final_assessment into a dataframe
    # Save the dataframe
    saved_file = '/Path/course_assessment.csv/'
    assess.to_csv('/Path/course_assessment.csv/', index=False)
  
    data = pd.DataFrame(credit_list) # convert the list of dictionary into a dataframe

    # Combine the course_list dataframe with the course credits dataframe
    combined_df = pd.concat([df, data], axis=1)
    # Save the dataframe
    saved_file = '/Path/course_credits.csv/'
    combined_df.to_csv('/Path/course_credits.csv/', index=False)

except Exception as e:
    print(f"Error extracting Level 4 courses: {e}")

# Close the browser
driver.quit()


